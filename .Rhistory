library("quantmod", lib.loc="C:/Program Files/R/R-3.2.0/library")
library("DMwR", lib.loc="C:/Program Files/R/R-3.2.0/library")
library("class", lib.loc="C:/Program Files/R/R-3.2.0/library")
library("rpart", lib.loc="C:/Program Files/R/R-3.2.0/library")
library("randomForest", lib.loc="C:/Program Files/R/R-3.2.0/library")
Tdata.train[,1] = trading.signals(Tdata.train[,1],0.1,-0.1)
data.model,data.window=c("1970-01-02","1999-12-31")))
Tdata.train = as.data.frame(modelData(
data.model,data.window=c("1970-01-02","1999-12-31")))
Tdata.eval = na.omit(as.data.frame(modelData(
data.model,data.window=c("2000-01-01","2009-09-15"))))
myATR = function(x) ATR(HLC(x))[, "atr"]
mySMI = function(x) SMI(HLC(x))[, "SMI"]
myADX = function(x) ADX(HLC(x))[, "ADX"]
myAroon = function(x) aroon(x[, c("High", "Low")])$oscillator
myBB = function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol = function(x) Delt(chaikinVolatility(x[, c("High","Low")]))[, 1]
myCLV = function(x) EMA(CLV(HLC(x)))[, 1]
myEMV = function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD = function(x) MACD(Cl(x))[, 2]
myMFI = function(x) MFI(x[, c("High", "Low", "Close")],x[, "Volume"])
mySAR = function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat = function(x) volatility(OHLC(x), calc = "garman")[,1]
data(GSPC)
library(randomForest)
data.model = specifyModel(T.ind(GSPC) ~ Delt(Cl(GSPC),k=1:10) +
myATR(GSPC) + mySMI(GSPC) + myADX(GSPC) + myAroon(GSPC) +
myBB(GSPC) + myChaikinVol(GSPC) + myCLV(GSPC) +
CMO(Cl(GSPC)) + EMA(Delt(Cl(GSPC))) + myEMV(GSPC) +
myVolat(GSPC) + myMACD(GSPC) + myMFI(GSPC) + RSI(Cl(GSPC)) +
mySAR(GSPC) + runMean(Cl(GSPC)) + runSD(Cl(GSPC)))
fold = sample(rep(1:5,each=18)) # creation des groupes B_v
cvpred = matrix(NA,nrow=90,ncol=10) # initialisation de la matrice
# des predicteurs
error = matrix(NA,nrow=100,ncol=10)
error_mean = c()
for (i in 1:100)  {
for (k in 1:10) {
for (v in 1:5)  {
sample1 = train[which(fold!=v),1:4]
sample2 = train[which(fold==v),1:4]
class1 = train[which(fold!=v),5]
cvpred[which(fold==v),k] = knn(sample1,sample2,class1,k=k)}}
class = as.numeric(train[,5])
error[i,]=apply(cvpred,2,function(x) sum(class!=x))}
for (i in 1:10) {
error_mean[i]=mean(error[,i])}
k_optimal = which(error_mean==min(error_mean))
library(class)
data(iris)
head(iris)
summary(iris)
train = iris[c(1:30,51:80,101:130),1:5]
test = iris[c(31:50,81:100,131:150),1:5]
pred = knn(train[,1:4], test[,1:4], train[,5], k = 3)
# display the confusion matrix
table(pred,test[,5])
# 5-fold cross-validation to select k
# from the set {1,...,10}
fold = sample(rep(1:5,each=18)) # creation des groupes B_v
cvpred = matrix(NA,nrow=90,ncol=10) # initialisation de la matrice
# des prédicteurs
for (k in 1:10)
for (v in 1:5){
sample1 = train[which(fold!=v),1:4]
sample2 = train[which(fold==v),1:4]
class1 = train[which(fold!=v),5]
cvpred[which(fold==v),k] = knn(sample1,sample2,class1,k=k)}
class = as.numeric(train[,5])
# display misclassification rates for k=1:10
apply(cvpred,2,function(x) sum(class!=x)) # calcule l'erreur de classification
fold = sample(rep(1:5,each=18)) # creation des groupes B_v
cvpred = matrix(NA,nrow=90,ncol=10) # initialisation de la matrice
# des predicteurs
error = matrix(NA,nrow=100,ncol=10)
error_mean = c()
for (i in 1:100)  {
for (k in 1:10) {
for (v in 1:5)  {
sample1 = train[which(fold!=v),1:4]
sample2 = train[which(fold==v),1:4]
class1 = train[which(fold!=v),5]
cvpred[which(fold==v),k] = knn(sample1,sample2,class1,k=k)}}
class = as.numeric(train[,5])
error[i,]=apply(cvpred,2,function(x) sum(class!=x))}
for (i in 1:10) {
error_mean[i]=mean(error[,i])}
k_optimal = which(error_mean==min(error_mean))
k_optimal
```{r include=FALSE}
library(DMwR)
data(GSPC)
T.ind = function(quotes, tgt.margin = 0.025, n.days = 10) {
v = apply(HLC(quotes), 1, mean)
r = matrix(NA, ncol = n.days, nrow = NROW(quotes))
for (x in 1:n.days) r[, x] = Next(Delt(v, k = x), x)
x = apply(r, 1, function(x) sum(x[x > tgt.margin | x <
-tgt.margin]))
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
library(quantmod)
candleChart(last(GSPC, "3 months"), theme = "white", TA = NULL)
avgPrice = function(p) apply(HLC(p), 1, mean)
addAvgPrice = newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind = newTA(FUN = T.ind, col = "red", legend = "tgtRet")
get.current.chob<-function(){quantmod:::get.current.chob()}
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addAvgPrice(on=1)")
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addAvgPrice(on=1)")
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addT.ind();addAvgPrice(on=1)")
myATR = function(x) ATR(HLC(x))[, "atr"]
mySMI = function(x) SMI(HLC(x))[, "SMI"]
myADX = function(x) ADX(HLC(x))[, "ADX"]
myAroon = function(x) aroon(x[, c("High", "Low")])$oscillator
myBB = function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol = function(x) Delt(chaikinVolatility(x[, c("High","Low")]))[, 1]
myCLV = function(x) EMA(CLV(HLC(x)))[, 1]
myEMV = function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD = function(x) MACD(Cl(x))[, 2]
myMFI = function(x) MFI(x[, c("High", "Low", "Close")],x[, "Volume"])
mySAR = function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat = function(x) volatility(OHLC(x), calc = "garman")[,1]
data(GSPC)
library(randomForest)
data.model = specifyModel(T.ind(GSPC) ~ Delt(Cl(GSPC),k=1:10) +
myATR(GSPC) + mySMI(GSPC) + myADX(GSPC) + myAroon(GSPC) +
myBB(GSPC) + myChaikinVol(GSPC) + myCLV(GSPC) +
CMO(Cl(GSPC)) + EMA(Delt(Cl(GSPC))) + myEMV(GSPC) +
myVolat(GSPC) + myMACD(GSPC) + myMFI(GSPC) + RSI(Cl(GSPC)) +
mySAR(GSPC) + runMean(Cl(GSPC)) + runSD(Cl(GSPC)))
set.seed(1234)
rf = buildModel(data.model,method="randomForest",
training.per=c(start(GSPC),index(GSPC["1999-12-31"])),
ntree=50, importance=T)
set.seed(1234)
rf = buildModel(data.model,method="randomForest",
training.per=c(start(GSPC),index(GSPC["1999-12-31"])),
ntree=50, importance=T)
head(rf@fitted.model$importance,5)
varImpPlot(rf@fitted.model, type = 1)
Variables_explicatives<-c("SAR","ADX","MACD","Volat","ATR","SMI","MFI","CLV")
Variables_explicatives2<-sapply(Variables_explicatives,
FUN=function(x){paste("my",x,"(GSPC)",sep="")})
formula<-as.formula(paste("T.ind(GSPC) ~ ", paste(Variables_explicatives2, collapse= "+")))
data.model2 <- specifyModel(formula)
Tdata.train = as.data.frame(modelData(
data.model,data.window=c("1970-01-02","1999-12-31")))
Tdata.eval = na.omit(as.data.frame(modelData(
data.model,data.window=c("2000-01-01","2009-09-15"))))
Tdata.eval[,1] = trading.signals(Tdata.eval[,1],0.1,-0.1)
Tdata.train[,1] = trading.signals(Tdata.train[,1],0.1,-0.1)
names(Tdata.eval)[1] = "signal"
names(Tdata.train)[1] = "signal"
summary(Tdata.train)
cvpred = matrix(NA,nrow=2430,ncol=10)  #Pour le recueil des résultats;
class=as.numeric(Tdata.eval[,1])       #Vraies classes de Tdata.eval;
for(i in (1:10))  {
cvpred[,i] = knn(Tdata.train[,-1], Tdata.eval[,-1] , Tdata.train[,1], k = i)
#table(cvpred[,i],Tdata.eval[,1])}
errors_knn = apply(cvpred,2,function(x) sum(class!=x))
library(class)
data(iris)
head(iris)
summary(iris)
train = iris[c(1:30,51:80,101:130),1:5]
test = iris[c(31:50,81:100,131:150),1:5]
pred = knn(train[,1:4], test[,1:4], train[,5], k = 3)
# display the confusion matrix
table(pred,test[,5])
# 5-fold cross-validation to select k
# from the set {1,...,10}
fold = sample(rep(1:5,each=18)) # creation des groupes B_v
cvpred = matrix(NA,nrow=90,ncol=10) # initialisation de la matrice
# des predicteurs
for (k in 1:10)
for (v in 1:5)
{
sample1 = train[which(fold!=v),1:4]
sample2 = train[which(fold==v),1:4]
class1 = train[which(fold!=v),5]
cvpred[which(fold==v),k] = knn(sample1,sample2,class1,k=k)
}
class = as.numeric(train[,5])
# display misclassification rates for k=1:10
apply(cvpred,2,function(x) sum(class!=x)) # calcule l'erreur de classification
library(DMwR)
data(GSPC)
T.ind = function(quotes, tgt.margin = 0.025, n.days = 10) {
v = apply(HLC(quotes), 1, mean)
r = matrix(NA, ncol = n.days, nrow = NROW(quotes))
for (x in 1:n.days) r[, x] = Next(Delt(v, k = x), x)
x = apply(r, 1, function(x) sum(x[x > tgt.margin | x <
-tgt.margin]))
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
library(quantmod)
candleChart(last(GSPC, "3 months"), theme = "white", TA = NULL)
avgPrice = function(p) apply(HLC(p), 1, mean)
addAvgPrice = newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind = newTA(FUN = T.ind, col = "red", legend = "tgtRet")
get.current.chob<-function(){quantmod:::get.current.chob()}
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addAvgPrice(on=1)")
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addAvgPrice(on=1)")
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addT.ind();addAvgPrice(on=1)")
library(DMwR)
data(GSPC)
T.ind = function(quotes, tgt.margin = 0.025, n.days = 10) {
v = apply(HLC(quotes), 1, mean)
r = matrix(NA, ncol = n.days, nrow = NROW(quotes))
for (x in 1:n.days) r[, x] = Next(Delt(v, k = x), x)
x = apply(r, 1, function(x) sum(x[x > tgt.margin | x <
-tgt.margin]))
if (is.xts(quotes))
xts(x, time(quotes))
else x
}
library(quantmod)
candleChart(last(GSPC, "3 months"), theme = "white", TA = NULL)
avgPrice = function(p) apply(HLC(p), 1, mean)
addAvgPrice = newTA(FUN = avgPrice, col = 1, legend = "AvgPrice")
addT.ind = newTA(FUN = T.ind, col = "red", legend = "tgtRet")
get.current.chob<-function(){quantmod:::get.current.chob()}
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addAvgPrice(on=1)")
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addAvgPrice(on=1)")
candleChart(last(GSPC, "3 months"), theme = "white", TA = "addT.ind();addAvgPrice(on=1)")
myATR = function(x) ATR(HLC(x))[, "atr"]
mySMI = function(x) SMI(HLC(x))[, "SMI"]
myADX = function(x) ADX(HLC(x))[, "ADX"]
myAroon = function(x) aroon(x[, c("High", "Low")])$oscillator
myBB = function(x) BBands(HLC(x))[, "pctB"]
myChaikinVol = function(x) Delt(chaikinVolatility(x[, c("High","Low")]))[, 1]
myCLV = function(x) EMA(CLV(HLC(x)))[, 1]
myEMV = function(x) EMV(x[, c("High", "Low")], x[, "Volume"])[,2]
myMACD = function(x) MACD(Cl(x))[, 2]
myMFI = function(x) MFI(x[, c("High", "Low", "Close")],x[, "Volume"])
mySAR = function(x) SAR(x[, c("High", "Close")])[, 1]
myVolat = function(x) volatility(OHLC(x), calc = "garman")[,1]
data(GSPC)
library(randomForest)
data.model = specifyModel(T.ind(GSPC) ~ Delt(Cl(GSPC),k=1:10) +
myATR(GSPC) + mySMI(GSPC) + myADX(GSPC) + myAroon(GSPC) +
myBB(GSPC) + myChaikinVol(GSPC) + myCLV(GSPC) +
CMO(Cl(GSPC)) + EMA(Delt(Cl(GSPC))) + myEMV(GSPC) +
myVolat(GSPC) + myMACD(GSPC) + myMFI(GSPC) + RSI(Cl(GSPC)) +
mySAR(GSPC) + runMean(Cl(GSPC)) + runSD(Cl(GSPC)))
set.seed(1234)
rf = buildModel(data.model,method="randomForest",
training.per=c(start(GSPC),index(GSPC["1999-12-31"])),
ntree=50, importance=T)
Tdata.train[,1] = trading.signals(Tdata.train[,1],0.1,-0.1)
names(Tdata.train)[1] = "signal"
summary(Tdata.train)
Tdata.train =as.data.frame(modelData(data.model,data.window=c("1970-01-02","1999-12-31")))
Tdata.eval=na.omit(as.data.frame(modelData(data.model,data.window=c("2000-01-01","2009-09-15"))))
regressionFormulaWithAllVariables = "signal ~ ."
library(rpart)
regressionFormulaWithImportantVariables = "signal ~ myATR.GSPC + mySMI.GSPC + myADX.GSPC + myCLV.GSPC +
myVolat.GSPC + myMACD.GSPC + myMFI.GSPC +mySAR.GSPC"
importantVars = c("myATR.GSPC","mySMI.GSPC","myADX.GSPC","myCLV.GSPC","myVolat.GSPC","myMACD.GSPC","myMFI.GSPC","mySAR.GSPC")
importantColumnsIndexes = c(1)
i=2
for( var in importantVars){
importantColumnsIndexes[i] = which(colnames(Tdata.train) == var)
i= i+1
}
#regressionFormula = regressionFormulaWithAllVariables
regressionFormula = regressionFormulaWithImportantVariables
rt.ai = rpart(regressionFormulaWithImportantVariables, data = Tdata.train[,importantColumnsIndexes],rpart.control(maxdepth = 2))
rt.ai = rpart(regressionFormulaWithAllVariables, data = Tdata.train)
rt.predictions.ai = predict(rt.ai, Tdata.train[,-1])
predictions.train.signal = trading.signals(rt.predictions.ai ,0.1,-0.1)
rt.predictions.eval = predict(rt.ai, Tdata.eval[,-1])
predictions.eval.signal = trading.signals(rt.predictions.eval ,0.1,-0.1)
table(predictions.train.signal,trading.signals(Tdata.train[,1],0.1,-0.1))
table(predictions.eval.signal,trading.signals(Tdata.eval[,1],0.1,-0.1))
prettyTree(rt.ai,col="navy",bg="lemonchiffon")
